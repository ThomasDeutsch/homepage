<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <title>Integration => people over process</title>
  <meta name="description" content="Integration">
  <meta name="author" content="Thomas Deutsch">
  <link rel="stylesheet" href="/styles/article.css">
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <div class="container">
      <article>
          <header>
            <div class="date">January 26, 2020</div>
            <figure>
              <img src="img/integrationTitle.svg"/>
            </figure>
            <h1 class="visually-hidden">Integration</h1>
            <h3 class="visually-hidden">people over process in modern software development</h3>
          </header>
          <section class="content">
            <p>One year ago, in January 2019, Chris Coyier released the article <a href="https://css-tricks.com/the-great-divide/">The Great Divide</a>.
              He shows that we are facing some challenges by introducing new disciplines and sub-disciplines to the field of software development.<br> 
              What do you need to learn, to call yourself a frontend developer? What even is frontend-development?<br>
              The difference between "front of the frontend" (UX, UI-Design, a11y) and "back of the frontend" (programming) shows a divide - that is not without cost.
            </p>
            <p>A cost that needs to be addressed: with every specialization  comes the need for integration.<br>
              I would argue, that this is mostly overlooked and it creates one of the biggest problems in modern software development.
            </p>
            <p>In this article, i will define the meaning of integration and why we need to address it.<br>
              I will describe a systemic problem at the very core of how we work, <br>
              and show a solution to resolve this problem - something you can use today.
            </p>
            <p>This is all in good spirit, as this article is about improvement and a positive outlook on what is possible.</p>
            <p>I hope that you will, more often than not, find a way to discover that integrated teams can be much bigger than the sum of their parts.</p>
          </section>
      
          <section class="content">
            <h2>System And Parts</h2>

            <p>A way to look at our situation, is through the lens of Systems Thinking.</p>
            <p>Systems Thinking was pioneered by the work of <a href="https://en.wikipedia.org/wiki/Russell_L._Ackoff">Russell Ackoff</a>. In this video, he talks about improvement. Something that you may see as fitting for this article.</p>
              <figure class="video" id="video1">
                <img src="img/playvideo.jpg" alt="play the youtube video">
                <svg version="1.1" id="YouTube_Icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px"
                  y="0px" width="71px" height="50px" viewBox="0 0 55 38.7" style="enable-background:new 0 0 55 38.7;" xml:space="preserve">
                <style type="text/css">
                  .st0{fill:#FFFFFF;}
                  .st1{opacity:0.12;fill:black;enable-background:new;}
                  .st2{fill:url(#SVGID_1_);}
                </style>
                <path id="Triangle" class="st0" d="M21.8,26.5l14.9-7.7L21.8,11V26.5z"/>
                <path id="The_Sharpness" class="st1" d="M21.8,11l13,8.7l1.8-0.9L21.8,11z"/>
                <g id="Lozenge">
                  <g>
                    <linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="27.5074" y1="-121" x2="27.5074" y2="-82.3" gradientTransform="matrix(1 0 0 1 0 121)">
                    <stop  offset="0" style="stop-color:#E52D27"/>
                    <stop  offset="1" style="stop-color:#BF171D"/>
                    </linearGradient>
                    <path class="st2" d="M54.5,8.3c0,0-0.5-3.8-2.2-5.5c-2.1-2.2-4.4-2.2-5.5-2.3C39.1,0,27.5,0,27.5,0h0c0,0-11.5,0-19.3,0.6
                      C7.2,0.7,4.8,0.7,2.7,2.9C1.1,4.6,0.5,8.3,0.5,8.3S0,12.8,0,17.3v4.2c0,4.5,0.5,8.9,0.5,8.9s0.5,3.8,2.2,5.5
                      c2.1,2.2,4.8,2.1,6.1,2.4c4.4,0.4,18.7,0.6,18.7,0.6s11.6,0,19.3-0.6c1.1-0.1,3.4-0.1,5.5-2.3c1.6-1.7,2.2-5.5,2.2-5.5
                      s0.5-4.5,0.5-8.9v-4.2C55,12.8,54.5,8.3,54.5,8.3z M21.8,26.5V11l14.9,7.8L21.8,26.5z"/>
                  </g>
                </g>
                </svg>
                <figcaption></figcaption>
              </figure>
            <p>We are facing a systemic problem:</p>

            <p>We are dividing the system of software development into parts (specializations).
                The assumption is, that if we improve every part separately, the system as a whole will improve.<br>
                But this is very misleading.<br>
                A system is a whole, that can't be divided into independent parts.<br>
                The parts are all interconnected. Improving a part will not necessarily improve the system as a whole.<br>
                Most properties of a system will derive from the interaction of its parts - not from the parts taken separately.
            </p>

            <p class="example">
              Example<br>
              When an architect designs a house, he can't design the rooms taken separately.<br>
              The rooms are all interconnected, and if he wants to make the bathroom bigger, he knows that this
              has an impact on other rooms and the structure of the house itself.
              For the best possible house, no room might be the best possible room.<br>
              Everything needs to be evaluated against the improvement of the whole.<br>
            </p>

            <p>This is directly reflected in how we develop the software itself.<br>
              We often act and think in silos, and our focus easily shifts from improving the software as a whole to improving specific elements we see as important.<br>
                UI-redesigns, performance optimizations and better code abstraction layers - there is always something we can make better.<br>
                At the end of the day it comes down to what we have done with our limited time, money and information.<br>
                If we only improve the parts without the focus on the improvement of the system as a whole, we will not only be wasting
                a lot of opportunities to deliver the best possible result to our customers, we will make the system worse.
            </p>
          </section>
          
          <section class="content">
            <h2>Hidden Cost</h2>
      
            <p>We assume that the right process (for example an agile framework) will bring everything together, but
            the truth is, that any process is limited to means of coordination.<br>
            We need a good process, but it is no substitute for integrative methods.</p>
            
            <figure>
              <img src="img/coordinationVsIntegration.svg" alt="">
              <figcaption>Think-Make-Check circle: coordination VS integration</figcaption>
            </figure>
            
            <p>Integration (on the right) can be shown as an overlap of multiple disciplines. It is more than bridging different disciplines. It is a common ground.<br>
              Without it, we are only able to throw our work over the fence for the next team to continue.<br>
            </p>

            <p class="example">There is something called a "Developer Handoff".<br>
              A process, where a designer will hand the results over to the development team.<br>
              If the designer made a good job, the developers are able to understand enough to implement the necessary code.<br>
              The work is divided, and for a time this seems to be a great idea - but over time, we can see what we have missed.<br>
              The necessary interactions between designers and developers.<br>
              Developers can get angry and frustrated. "What are the designers doing? This is way to complicated!".<br>
            </p>
            
            <p>This is why we need coordination and integration. They are a complementary pair.<br>
              On a coordination level, we answer the questions on how to do things (the process).<br>
              Integration is not about the process, it is about a common ground that enables us to share an understanding.<br>
              TODO: WHY DO WE NEED INTEGRATION?
              Integrated teams are able to share an understanding to add value efficiently.<br>
            </p>
            
            <figure>
              <img src="img/infoknowlunder.svg" alt="">
              <figcaption>Information -> Knowledge -> Understanding</figcaption>
            </figure>

            <p class="quote">An ounce of information is worth a pound of data.<br>
              An ounce of knowledge is worth a pound of information.<br>
              An ounce of understanding is worth a pound of knowledge.
            </p>

            <p>Can we make choices to enable better integration?<br>
              I think that we have to address a situation at the very core of how we work.<br>
              If we would resolve this issue, we would create opportunities to unify different disciplines.<br>
            </p>
          </section>

          <section>
            <h2>Duality</h2>

            <p class="example">You are in sprint 32.<br>
              Someone shows you a database schema.<br>
              Do we need field "x"?<br>
              You could say: it depends.<br>
              It depends on what?<br>
              It depends on the context<br>
            </p>
            <p>Your answer could be: Yes, we need field "x" because it is required for the user registration process and for...<br>
                This is an answer someone might expect, but to be able to give it, a developer needs to know all the scenarios
                that need field "x" and this information might not be easily found, as it got complected into the structure.
            </p>
              
            <figure>
              <img src="img/divide.svg" alt="">
              <figcaption>the divide</figcaption>
            </figure>

            <p>Design and Testing will describe the software in terms of scenarios (seen on the left).<br>
              On the right side, developers will describe the software in terms of an executable software construct.</p>
              
            <p>This is the duality. On one hand, we have a scenario based thinking that lets us define in a very human way how things
              should work. This is in fact how we -as humans- try to make sense of the word that surrounds us.<br>
              Like: "the user is able to register by providing the needed information".
            </p>
              
            <p>On the other hand, we write software, because we need something that is machine-executable.
              We add methods, classes, components, ..., to the software construct, so that it is capable of running our scenario.
              "we need to implement a new service, the form-component needs to include field x, ..."</p>
          
              <figure>
                  <img src="img/driftapart.svg" alt="">
                  <figcaption>drifting apart</figcaption>
              </figure>

              <p>This is the divide at the very core of how we work.
              </p>
          </section>



          <section>
            <h2>Problems</h2>

              <p>From a developer perspective, this duality creates a world of problems. Here are my top 3.</p>
              
              <h4>1. complecting scenarios</h4>
              <p>After adding functionality to the same part of our construct, we might fail to reason about it.<br>
                What scenarios have shaped this component?<br>
                Why is this if/else here?<br>
              If we are not able to reason about our code, how can we make confident changes?<br>
              Complecting scenarios will result in complexity.</p>

              <h4>2. enabling unwanted scenarios</h4>
              <p>When we implement a new feature, we add new functionality to parts of our construct - 
                but what unwanted scenarios we have we accidentally enabled, too?<br>
                Bob Martin tells me that i need "negative tests".<br>
                It is like the advice to "expect the unexpected" - those tests are not easy to find.<br>
              </p>
              
              <h4>3. change of mindset</h4>
              <p>We want to increase the power of our software.<br>
              The wish is, that the software will be so well constructed, that it would be easy to enable possible future scenarios, or even possible future projects.<br>
              We focus on our powerful software - and less on the needs of our users.</p>
              <br>
          </section>


          <section>
            <h2>Resolving</h2>
            <p>Different specializations not only need to be coordinated - they need to be integrated as well.<br>
              To enable integration between two disciplines, we need something that serves as a common ground.<br>
              In other words, it would be beneficial to talk the same language when we talk about software.<br>
          </p>

          <p><b>The goal</b> is to keep an artifact during the whole process. From design over to development and testing.<br>
          </p>

          <p>Modelling languages for reactive systems, like Statecharts come to mind.<br>
          </p>
          </section>


          <section>
            <h2>Statecharts</h2>
            
            <p>TODO: short introduction on statecharts.<br>
              They serve as an integrative tool, because the artifact can be used across different disciplines, as long at the participants understand
              the basic building blocks. - todo: make clear that people need to learn the modelling language.<br>
              People from different disciplines are enabled to communicate with the help of the statechart graph.<br>
            </p>
      
            <p class="example">
              An excerpt from <a href="http://www.wisdom.weizmann.ac.il/~harel/papers/Statecharts.History.pdf">Statecharts in the Making</a> by Prof. David Harel:<br><br>
              I recall an anecdote from somewhere in late 1983, in which in the midst of one of the
              sessions at the IAI ... There was a knock on the
              door and in came one of the air force pilots from the
              headquarters of the project. He was a member of the
              "customer" requirements team ... he had never seen a state machine or a state diagram
              before, not to mention a statechart.<br> 
              He stared for a moment at this picture on the blackboard, with its complicated mess
              of blobs, blobs inside other blobs, colored arrows splitting
              and merging, etc., and asked "What's that?"<br>
              One of the members of the team said "Oh, that's the behavior of the
              so-and-so part of the system, and, by the way, these
              rounded rectangles are states, and the arrows are transitions
              between states". And that was all that was said.<br>
              The pilot stood there studying the blackboard for a minute or two,
              and then said, "I think you have a mistake down here, this
              arrow should go over here and not over there"; and he was
              right.
            </p>

            <p>Todo: The statechart approach is intra-object, in that ultimately
                the recommendation is to prepare a statechart for each
                object of the system (or for each task, function, component,
                etc., whatever artifacts your system will be composed of).
                Of course, the statecharts are to also contain information
                about the communication between the objects, and one
                could build special controlling statecharts to concentrate on
                these aspects; however, by and large, the idea of finite-state
                machines in general, and statecharts in particular, is to
                provide a way for specifying the behavior of the system per
                object in an intra-object fashion. The more recent work has
                to do with scenario-based, inter-object specification. </p>

          </section>


<section>
  <h2>Inter-Object Modelling</h2>
      <p>The idea is to concentrate on specifying the behavior between
          and among the objects (or tasks, functions, components,
          etc.). The main lingua franca for describing the behavior of
          the system would have to be a language for specifying
          communication and collaboration between the objects</p>

      <figure>
          <img src="img/scenariosandconstruct.svg" alt="">
          <figcaption>scenarios are like threads that use different parts of the construct.</figcaption>
      </figure>

      <p>For example: A button to send a request, or the service that makes an api call, can be part of the same scenario, even if they are in different parts of the construct.<br>
      </p>
      <p>The big difference between Scenario Based Programming is that scenarios are intra-object. Statecharts are intra-Object: https://arxiv.org/pdf/1911.10691.pdf<br>
      </p>
    </section>

    
    <section>
      <h2>Scenario Based Programming</h2>

      <h4>TODO: show a user-flow example that shows the inter-object behaviour of SBP.</h4>
      <ul>
          <li>show user flow</li>
          <li>add scenario based programming elements</li>
          <li>describe interactions between UX and DEV</li>
          <li>describe wait, block and request</li>
        </ul>
    </section>

    <section>
        <h2>What Is Next?</h2>

        <p>In the next article i go into code details.<br>
          I will show the benefits for testing and describe a full circle with this integrative core.<br>
          It turns out that scenarios really shine, when we look at intra-component functionality.<br>
          Use <a href="../../rss.xml">this RSS-Feed</a> to be notified.<br>
          Or follow me at twitter <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>.<br>
        </p>

        <p>Thanks for reading this article.<br>
          If you would like to say hello, please do so.<br>
          Do you have other ideas on how to enable integration as a central part of your process?<br>
        </p>

        <p>
          <h4>If you want to know more...</h4>
          <ul>
            <li><a href="https://medium.com/@lmatteis/b-threads-programming-in-a-way-that-allows-for-easier-changes-5d95b9fb6928">B-threads article from Luca Matteis</a></li>
            <li><a href="http://www.wisdom.weizmann.ac.il/~bprogram/">Behavioral Programming Introduction (page)</a></li>
            <li><a href="https://www.youtube.com/watch?v=EbLh7rZ3rhU">Systems Thinking by Dr. Russell Ackoff (video)</a></li>
            <li><a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple made Easy - Rich Hickey (video)</a></li>
            <li><a href="http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf">Can Programming Be Liberated, Period? (pdf)</a></li>
            <li><a href="https://medium.com/@dschnr/better-reusable-react-components-with-the-overrides-pattern-9eca2339f646">Overrides Pattern (page)</a></li>
          </ul>
        </p>
    </section>


  </article>
  <aside>
    <img src="img/profile.jpg"/>
    <div class="author">Thomas Deutsch</div>
    <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>
  </aside>
  </div>

  <script>
    var el = document.getElementById("video1");
    el.onclick = function() {
      var newEl = document.createElement('p');
      newEl.innerHTML = '<iframe width="100%" height="315" src="https://www.youtube.com/embed/OqEeIG8aPPk?start=560&autoplay=1&showinfo=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>';
      el.parentNode.replaceChild(newEl, el);
    };
  </script>
</body>
</html>
