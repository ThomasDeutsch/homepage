<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <title>Integration => people over process</title>
  <meta name="description" content="Integration">
  <meta name="author" content="Thomas Deutsch">
  <link rel="stylesheet" href="/styles/article.css">
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <div class="container">
      <article>
          <header>
            <div class="date">January 24, 2020</div>
            <figure>
              <img src="img/integrationTitle.svg"/>
            </figure>
            <h1 class="visually-hidden">Integration</h1>
            <h3 class="visually-hidden">people over process in modern software development</h3>
          </header>
          <section class="content">
            <p>One year ago, in January 2019, Chris Coyier released the article <a href="https://css-tricks.com/the-great-divide/">The Great Divide</a>.
              He shows that we are facing some challenges by introducing new disciplines and sub-disciplines to the field of software development.<br> 
              What do you need to learn, to call yourself a frontend developer? What even is frontend-development?<br>
              The difference between "front of the frontend" (UX, UI-Design, a11y) and "back of the frontend" (programming) shows a divide - that is not without cost.
            </p>
            <p>A cost that needs to be addressed: with every specialization  comes the need for integration.<br>
              I would argue, that this is mostly overlooked and it creates one of the biggest problems in modern software development.
            </p>
            <p>In this article, i will define the cost that comes with our specializations and why we need to address it.<br>
              I will describe a systemic problem at the very core of how we work, <br>
              and show a solution to resolve this problem - something you can use today.
            </p>
            <p>This is all in good spirit, as this article is about improvement and a positive outlook on what is possible.</p>
            <p>I hope that you will, more often than not, find a way to discover that integrated teams can be much bigger than the sum of its parts.</p>
          </section>
      
          <section class="content">
            <h2>System And Parts</h2>

            <p>A way to look at our situation, is through the lens of Systems Thinking.</p>
            <p>Systems Thinking was pioneered by the work of <a href="https://en.wikipedia.org/wiki/Russell_L._Ackoff">Russell Ackoff</a>. This is one of my favorite clips, where
              he talks about improvement. Something that you may see as fitting for this article.</p>
              <figure class="video" id="video1">
                <img src="img/playvideo.jpg" alt="play the youtube video">
                <svg version="1.1" id="YouTube_Icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px"
                  y="0px" width="71px" height="50px" viewBox="0 0 55 38.7" style="enable-background:new 0 0 55 38.7;" xml:space="preserve">
                <style type="text/css">
                  .st0{fill:#FFFFFF;}
                  .st1{opacity:0.12;fill:black;enable-background:new;}
                  .st2{fill:url(#SVGID_1_);}
                </style>
                <path id="Triangle" class="st0" d="M21.8,26.5l14.9-7.7L21.8,11V26.5z"/>
                <path id="The_Sharpness" class="st1" d="M21.8,11l13,8.7l1.8-0.9L21.8,11z"/>
                <g id="Lozenge">
                  <g>
                    <linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="27.5074" y1="-121" x2="27.5074" y2="-82.3" gradientTransform="matrix(1 0 0 1 0 121)">
                    <stop  offset="0" style="stop-color:#E52D27"/>
                    <stop  offset="1" style="stop-color:#BF171D"/>
                    </linearGradient>
                    <path class="st2" d="M54.5,8.3c0,0-0.5-3.8-2.2-5.5c-2.1-2.2-4.4-2.2-5.5-2.3C39.1,0,27.5,0,27.5,0h0c0,0-11.5,0-19.3,0.6
                      C7.2,0.7,4.8,0.7,2.7,2.9C1.1,4.6,0.5,8.3,0.5,8.3S0,12.8,0,17.3v4.2c0,4.5,0.5,8.9,0.5,8.9s0.5,3.8,2.2,5.5
                      c2.1,2.2,4.8,2.1,6.1,2.4c4.4,0.4,18.7,0.6,18.7,0.6s11.6,0,19.3-0.6c1.1-0.1,3.4-0.1,5.5-2.3c1.6-1.7,2.2-5.5,2.2-5.5
                      s0.5-4.5,0.5-8.9v-4.2C55,12.8,54.5,8.3,54.5,8.3z M21.8,26.5V11l14.9,7.8L21.8,26.5z"/>
                  </g>
                </g>
                </svg>
                <figcaption></figcaption>
              </figure>
            <p>I will use some of his words, for the following explanation.</p>

            <p>We are dividing the system of software development into parts (specializations).
                The assumption is, that if we improve every part separately, the system as a whole will improve.<br>
                But this is very misleading.<br>
                A system is a whole, that can not be divided into independent parts.<br>
                The parts are all interconnected. Improving a part will not necessarily improve the system as a whole.<br>
                Most properties of a system will derive from the interaction of its parts - not from the parts taken separately.
            </p>

            <p class="example">
              Example<br>
              When an architect designs a house, he can not design the rooms taken separately.<br>
              The rooms are all interconnected, and if he wants to make the bathroom bigger, he knows that this
              has an impact on other rooms and the structure of the house itself.
              For the best possible house, no room might be the best possible room.<br>
              Everything needs to be evaluated against the improvement of the whole.<br>
            </p>

            <p>This is directly reflected in how we develop the software itself.<br>
              We often act and think in silos, and our focus easily shifts from improving the software as a whole to improving specific elements we see as important.<br>
                UI-redesigns, performance optimizations and better code abstraction layers - there is always something we can make better.<br>
                At the end of the day it comes down to what we have done with our limited time, money and information.<br>
                If we only improve the parts without the focus on the improvement of the system as a whole, we will not only be wasting
                a lot of opportunities to deliver the best possible result to our customers, we will make the system worse.
            </p>
          </section>
          
          <section class="content">
            <h2>Hidden Cost</h2>
      
            <p>Because all the parts are interconnected, every specialization we introduce will create the need to be integrated into a whole.<br>
            We assume that the right process (for example an agile framework) will bring everything together, but
            the truth is, that any process is limited to means of coordination. Integration on the other hand, is about a common ground, an overlap of different
            disciplines that can result in a shared language and artifact.<br>
            We need a good process, but it is no substitute for integrative methods.</p>

            <p>Modern software development is often associated with an iterative processes (visualized as circles).<br>
              Any agile framework will make use of one or multiple of those iterative processes. In this case visualized by a think-make-check circle.<br>
              Here, the process is shown in two different ways. On the left, coordination with an emphasis on direction. Integration on the right side where
              different fields of specialization are shown as colored areas.
            </p>
            
            <figure>
              <img src="img/coordinationVsIntegration.svg" alt="">
              <figcaption>Think-Make-Check circle: coordination VS integration</figcaption>
            </figure>
            
            <p>On the right side, we see overlapping areas. They represent a unification of two or more disciplines.<br>
              This can be seen as a shared language or artifact - something where both disciplines can find ways to work together.<br>
              Without it, we are only able to throw our work over the fence for the next team to continue.<br>
            </p>

            <p class="example">There is something called a "Developer Handoff".<br>
              A process, where a designer will hand the results over to the development team.<br>
              If the designer made a good job, the developers are able to understand enough to implement the necessary code.<br>
              The work is divided, and for a time this seems to be a great idea - but over time, we can see what we have missed.<br>
              The necessary interactions between designers and developers.<br>
              Even if the developers are able to implement the code, what about the shared understanding of the whole?<br>
              Why are the designs made that way? What about the developers who would love to give an opinion before the designs are finished?<br>
              Developers can get angry and frustrated. "What are the designers doing? This is way to complicated!".<br>
            </p>

            <p>For many companies, this is the default behaviour. It is the culture of our economy: the division of labor.<br>
            As a result, a strict process might be seen as overly beneficial to your employee.<br>
            To be a worker in a process, your work is more easily measured and checked, to optimize for efficiency.<br>
            Coordination enables us to do things the right way.</p>

            <p>On the other hand, we have integration.<br>
            Integration enables us to do the right thing.<br>
            Integrated teams share an understanding of the software and its goals.<br>
            Only then, the question can be answered: Are we improving our software with this change?<br>
            A team can be very efficient in adding new features, but features do not guarantee an improvement.<br>
          </p>
            
            <p>This is why we need coordination and integration. They are a complementary pair.<br>
              On a coordination level, we answer the questions on how to do things. This leads to knowledge.<br>
              Integration is on next level. By asking "why" questions we can gain understanding. 
              Only with coordination and integration we can add value efficiently. This is called effectiveness.
            </p>
            
            <figure>
              <img src="img/infoknowlunder.svg" alt="">
              <figcaption>Information -> Knowledge -> Understanding</figcaption>
            </figure>

            <p class="quote">An ounce of information is worth a pound of data.<br>
              An ounce of knowledge is worth a pound of information.<br>
              An ounce of understanding is worth a pound of knowledge.
            </p>

            <p>
              We are very much devoted to: "how" to do things.<br>
              Integration is hard to grasp and impossible to manage.<br>
              It is something behind and around the process we have chosen.<br>
              Can we make choices to enable better integration?
            </p>

            <p>Somehow, we can.<br>
            When we leave our desk and ask a designer/developer a question that starts with "why".<br>
            By not throwing work over the fence and being open for feedback.<br>
            But at the end, we can only do so much. For this to work, everyone needs to be on board.<br>
            Advice to not "disturb" the developers/designers, is more common than you might expect.<br>
            “Culture eats strategy for breakfast” - and you can feel it.<br>
            </p>

            <p>What if we change the system?<br>
              What if we could have a system where an integrative method is as essential as the process we have chosen?<br>
              A system that will provide a common ground that is not easily lost.<br>
              I think that we have to address a situation at the very core of how we work.<br>
              There is a duality, and if we manage to resolve this duality, we will have created a common ground at the very core of how we work.<br>
            </p>
          </section>

          <section>
            <h2>Duality</h2>

            <p class="example">You are in sprint 32.<br>
              Someone shows you a database schema.<br>
              Do we need field "x"?<br>
              You could say: it depends.<br>
              It depends on what?<br>
              It depends on the context<br>
            </p>
            <p>Your answer could be: Yes, we need field "x" because it is required for the user registration process and for...<br>
                This is an answer someone might expect, but to be able to give it, a developer needs to know all the scenarios
                that need field "x" and this information might not be easily found, as it got complected into the structure.
            </p>
              
            <figure>
              <img src="img/divide.svg" alt="">
              <figcaption>the divide</figcaption>
            </figure>

            <p>Design and Testing will describe the software in terms of scenarios (seen on the left).<br>
              On the right side, developers will describe the software in terms of an executable software construct.</p>
              
            <p>This is the duality. On one hand, we have a scenario based thinking that lets us define in a very human way how things
              should work. This is in fact how we -as humans- try to make sense of the word that surrounds us.<br>
              Like: "the user is able to register by providing the needed information".
            </p>
              
            <p>On the other hand, we write software, because we need something that is machine-executable.
              We add methods, classes, components, ..., to the software construct, so that it is capable of running our scenario.
              "we need to implement a new service, the form-component needs to include field x, ..."</p>
              

          
              <figure>
                  <img src="img/driftapart.svg" alt="">
                  <figcaption>drifting apart</figcaption>
              </figure>

              <p>This is the divide at the very core of how we work.<br>
                A duality that is hidden, and deeply ingrained in every iterative process.<br>
              </p>
          </section>



          <section>
            <h2>Problems</h2>

              <p>From a developer perspective, this duality creates a world of problems. Here are my top 4.</p>
              
              <h4>1. complecting scenarios</h4>
              <p>After adding functionality to the same part of our construct, we might fail to reason about it.<br>
                What scenarios have shaped this component?<br>
                Why is this if/else here?<br>
              If we are not able to reason about our code, how can we make confident changes?<br>
              Complecting scenarios will result in complexity.</p>

              <h4>2. enabling unwanted scenarios</h4>
              <p>When we implement a new feature, we add new functionality to parts of our construct - 
                but what unwanted scenarios we have we accidentally enabled, too? can we test this?<br>
                Bob Martin tells me that i need "negative tests". It is like the advice to "expect the unexpected".
              </p>
              
              <h4>3. change in mindset</h4>
              <p>We want to increase the power of our software.<br>
              The wish is, that the software will be so well constructed, that it would be easy to enable possible future scenarios, or even possible future projects.<br>
              We focus on our powerful software - and less on the needs of our users.</p>

              <h4>4. programmer convenience</h4>
              <p>The constructs have attributes of themselves, as we like to think about elegant abstractions or the latest version of framework x.<br>
                Without the focus on the software as a whole, we see all the promoted benefits of adding framework x - and only some of the drawbacks.
                Before i quote every part of the talk <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple Made Easy</a> by Rich Hickey, please
                go ahead and watch it.<br>
              </p>
              <br>
              <p>I would argue that developers suffer the most from the consequences of this divide.<br>
              But those problems are somehow self-inflicted. Developers need to find ways to assess the construct based on the artifacts.</p>

              <p>At the end, everybody needs to pay the consequences.<br>
                From my point of view, this duality is one of the biggest problems in modern software development.<br>
                Maybe we need another big crisis for this to change. Maybe the growing success of the no-code movement will teach us.<br>
              </p>

              <p>Luckily, this article is about improvement and a positive outlook, and i promised a practical solution for this problem.<br>
                It is not a silver bullet, but i hope i can demonstrate that there is a choice.<br>
              </p>
          </section>


          <section>
            <h2>TLDNR</h2>
            <p>In this article, we have seen that different specializations not only need to be coordinated - they need to be integrated as well.<br>
              Only then, we go to the next level where we can work on a shared understanding - and this will open the door for effective teams.<br>
              Integration needs to be a central property like the process itself.<br>
              To be able to do so, we resolve a duality at the very core of how we work, and gain something that can be described as a common ground.<br>
              This common ground is prominently present for every specialization - it is the artifact - the scenario we want to enable.<br>
          </p>
          </section>


          <section>
            <h2>Experiment</h2>

            <p>At this point, it all comes down to an experiment.<br>
              What will happen if the scenarios we want to enable are directly reflected in our code?<br>
              What will happen if the scenarios can be added/removed in a modular way?<br>
              If the same scenario can be found in design, development and testing, will this be a common ground and an opportunity to unite different specializations?<br>
            </p>

            <p>For this experiment, we will develop a simple image slider.<br>
              Our team has agreed on a couple of requirements.<br>
              <ul>
                <li>only one slide (the current slide) is shown</li>
                <li>The user is able to slide to the left and right.</li>
                <li>The slider can rotate in both directions.</li>
                <li>The slider will have a play function and slides after x ms.</li>
                <li>The slider can be paused at any time.</li>
                <li>Bulletpoints can be used to jump to a specific slide.</li>
                <li>If the user changes slides manually, the slider will pause.</li>
                <li>The slider will start to play automatically</li>
              </ul>
            </p>

            <p>Designers have sketched some first designs, and included input from the developers.<br>
              They have found async processes and edge-cases that need to be reflected in the UI as well.<br>
              <ul>
                <li>The slides are loaded asynchronously. (show a spinner ?)</li>
                <li>If there is only one slide, the slider has no functionality (show no buttons ?)</li>
              </ul>
            </p>

            <p>The developers started coding and this is the scaffolding of the discussed scenarios in code:<br>
            </p>

          <div style="background: #f0f3f3; overflow:auto;font-size:.8em; padding:1em; ">
  <pre style="margin: 0; line-height: 125%;width:0;">(scenario) <span style="color: #555555">=&gt;</span> {
  <span style="color: #006699; font-weight: bold">const</span> items <span style="color: #555555">=</span> scenario(loadItems, [url]).value;
  <span style="color: #006699; font-weight: bold">if</span>(items) {
    <span style="color: #006699; font-weight: bold">const</span> index <span style="color: #555555">=</span> scenario(showCurrentSlide, [items]).value;
    <span style="color: #006699; font-weight: bold">if</span>(items.length <span style="color: #555555">&gt;</span> <span>1</span>) {
      scenario(jumpToSlide, [items.length]);
      <span style="color: #006699; font-weight: bold">const</span> leftRight <span style="color: #555555">=</span> scenario(slideLeftRight, [index, items.length]);
      <span style="color: #006699; font-weight: bold">if</span>(leftRight) {
        scenario(rotate, [index, items.length]);
        <span style="color: #006699; font-weight: bold">const</span> isPlaying <span style="color: #555555">=</span> scenario(playPause, [<span>3000</span>]).value;
        <span style="color: #006699; font-weight: bold">if</span>(isPlaying) {
          scenario(pauseOnIndexChange);
        }
        scenario(autoplay);
      }
    }
  }
};</pre></div>
      <p>The difference between this, and something like redux-saga is best described when we look at the scenario itself.<br>
        Scenarios represent threads of behavior. Those threads run above the software construct.<br>
      </p>

      <figure>
          <img src="img/scenariosandconstruct.svg" alt="">
          <figcaption>scenarios are like threads that use different parts of the construct.</figcaption>
      </figure>

      <p>Following a thread like "the user needs to register before he can post a comment" can touch many parts of the construct.<br>
        For example the button to send a request, or the service service that make the api call.<br>
        The main goal here, is to represent the scenarios in code, the goals of redux-saga is to make side-effects easier to manage.<br>
      </p>

      <p>If you want to go into the details - <a href="https://codesandbox.io/s/first-final-design-6xccf">here is the complete code</a>.<br>
        There is a lot to unpack how the modular scenario system is constructed.<br>
        A detailed description will follow in the next article.<br>
      </p>
      
      <p>The scaffolding is needed for a simple reason: hierarchy.<br>
        Some scenarios only make sense, if other scenarios are enabled or in a specific state.<br>
        For example, we do not need the scenario "jumpToSlide", if there is only one slide.<br>
      </p>
    </section>


    <section>
      <h2>First Findings</h2>
      <p>
        <ol>
          <li>This shows that it is indeed possible to keep the artifact as a central element.<br>
            That we have the possibility to transition from the scenario in the requirement to the scenario in code.<br>
            Not all requirements can be modularized this way.<br>
            For example, technical requirements like "needs to be compatible with IE 11" are excluded.<br>
          </li>
          <li>We have provided a great place to start, when we want to understand our code.<br>
            In this scenario scaffolding, we find all the behaviours we enabled for this component.<br>
            This can be amazing for reusable components.<br>
            Instead of heaving an options-json to enable/disable functionality, we can simply change the scaffolding.<br>
          </li>
          <li>Making changes requires the developer to understand how the scenarios need to be constructed.<br>
            If the developer understands this modular system, he is able to add new scenarios, without knowing how other scenarios are implemented.<br>
          </li>
          <li>That it is possible to integrate scenario based programming into the current way we write UI Components.<br>
            This is demonstrated by using a react-hook.<br>
          </li>
        </ol>
      </p>
    </section>


    <section>
        <h2>What Is Next?</h2>
        <p>First, thanks for reading this article.<br>
          If you would like to say hello, please do so.<br>
          Do you have other ideas on how to enable integration as a central part of your process?<br>
          Do you have questions? Any suggestions on how to improve this article?<br>
        </p>

        <p>In the next article i go into code details. You can find the complete code here.<br>
          Then i will show the benefits for testing and describe a full circle with this integrative core.<br>
          Use <a href="../../rss.xml">this RSS-Feed</a> to be notified.<br>
          Or follow me at twitter: <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>.<br>
        </p>

        <p>
          <h4>If you want to know more...</h4>
          <ul>
            <li><a href="https://medium.com/@lmatteis/b-threads-programming-in-a-way-that-allows-for-easier-changes-5d95b9fb6928">B-threads article from Luca Matteis</a></li>
            <li><a href="http://www.wisdom.weizmann.ac.il/~bprogram/">Behavioral Programming Introduction (page)</a></li>
            <li><a href="https://www.youtube.com/watch?v=EbLh7rZ3rhU">Systems Thinking by Dr. Russell Ackoff (video)</a></li>
            <li><a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple made Easy - Rich Hickey (video)</a></li>
            <li><a href="http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf">Can Programming Be Liberated, Period? (pdf)</a></li>
            <li><a href="https://medium.com/@dschnr/better-reusable-react-components-with-the-overrides-pattern-9eca2339f646">Overrides Pattern (page)</a></li>
          </ul>
        </p>
    </section>


  </article>
  <aside>
    <img src="img/profile.jpg"/>
    <div class="author">Thomas Deutsch</div>
    <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>
  </aside>
  </div>

  <script>
    var el = document.getElementById("video1");
    el.onclick = function() {
      var newEl = document.createElement('p');
      newEl.innerHTML = '<iframe width="100%" height="315" src="https://www.youtube.com/embed/OqEeIG8aPPk?start=560&autoplay=1&showinfo=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>';
      el.parentNode.replaceChild(newEl, el);
    };
  </script>
</body>
</html>