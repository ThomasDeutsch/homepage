<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <title>Integration => people over process</title>
  <meta name="description" content="Integration">
  <meta name="author" content="Thomas Deutsch">
  <link rel="stylesheet" href="/styles/article.css">
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <div class="container">
      <article>
          <header>
            <div class="date">January 26, 2020</div>
            <figure>
              <img src="img/integrationTitle.svg"/>
            </figure>
            <h1 class="visually-hidden">Integration</h1>
            <h3 class="visually-hidden">people over process in modern software development</h3>
          </header>
          <section class="content">
            <p>One year ago, in January 2019, Chris Coyier released the article <a href="https://css-tricks.com/the-great-divide/">The Great Divide</a>.
              He shows that we are facing some challenges by introducing new disciplines and sub-disciplines to the field of software development.<br> 
              What do you need to learn, to call yourself a frontend developer? What even is frontend-development?<br>
              The difference between "front of the frontend" (UX, UI-Design, a11y) and "back of the frontend" (programming) shows a divide - that is not without cost.
            </p>
            <p>A cost that needs to be addressed: with every specialization  comes the need for integration.<br>
              I would argue, that this is mostly overlooked and it creates one of the biggest problems in modern software development.
            </p>
            <p>In this article, i will define the meaning of integration and why we need to address it.<br>
              I will describe a systemic problem at the very core of how we work, <br>
              and show a solution to resolve this problem - something you can use today.
            </p>
            <p>This is all in good spirit, as this article is about improvement and a positive outlook on what is possible.</p>
            <p>I hope that you will, more often than not, find a way to discover that integrated teams can be much bigger than the sum of their parts.</p>
          </section>
      
          <section class="content">
            <h2>System And Parts</h2>

            <p>A way to look at our situation, is through the lens of Systems Thinking.</p>
            <p>Systems Thinking was pioneered by the work of <a href="https://en.wikipedia.org/wiki/Russell_L._Ackoff">Russell Ackoff</a>. In this video, he talks about improvement. Something that you may see as fitting for this article.</p>
              <figure class="video" id="video1">
                <img src="img/playvideo.jpg" alt="play the youtube video">
                <svg version="1.1" id="YouTube_Icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px"
                  y="0px" width="71px" height="50px" viewBox="0 0 55 38.7" style="enable-background:new 0 0 55 38.7;" xml:space="preserve">
                <style type="text/css">
                  .st0{fill:#FFFFFF;}
                  .st1{opacity:0.12;fill:black;enable-background:new;}
                  .st2{fill:url(#SVGID_1_);}
                </style>
                <path id="Triangle" class="st0" d="M21.8,26.5l14.9-7.7L21.8,11V26.5z"/>
                <path id="The_Sharpness" class="st1" d="M21.8,11l13,8.7l1.8-0.9L21.8,11z"/>
                <g id="Lozenge">
                  <g>
                    <linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="27.5074" y1="-121" x2="27.5074" y2="-82.3" gradientTransform="matrix(1 0 0 1 0 121)">
                    <stop  offset="0" style="stop-color:#E52D27"/>
                    <stop  offset="1" style="stop-color:#BF171D"/>
                    </linearGradient>
                    <path class="st2" d="M54.5,8.3c0,0-0.5-3.8-2.2-5.5c-2.1-2.2-4.4-2.2-5.5-2.3C39.1,0,27.5,0,27.5,0h0c0,0-11.5,0-19.3,0.6
                      C7.2,0.7,4.8,0.7,2.7,2.9C1.1,4.6,0.5,8.3,0.5,8.3S0,12.8,0,17.3v4.2c0,4.5,0.5,8.9,0.5,8.9s0.5,3.8,2.2,5.5
                      c2.1,2.2,4.8,2.1,6.1,2.4c4.4,0.4,18.7,0.6,18.7,0.6s11.6,0,19.3-0.6c1.1-0.1,3.4-0.1,5.5-2.3c1.6-1.7,2.2-5.5,2.2-5.5
                      s0.5-4.5,0.5-8.9v-4.2C55,12.8,54.5,8.3,54.5,8.3z M21.8,26.5V11l14.9,7.8L21.8,26.5z"/>
                  </g>
                </g>
                </svg>
                <figcaption></figcaption>
              </figure>
            <p>I will summarize some of his points, for the following explanation.</p>

            <p>We are dividing the system of software development into parts (specializations).
                The assumption is, that if we improve every part separately, the system as a whole will improve.<br>
                But this is very misleading.<br>
                A system is a whole, that can't be divided into independent parts.<br>
                The parts are all interconnected. Improving a part will not necessarily improve the system as a whole.<br>
                Most properties of a system will derive from the interaction of its parts - not from the parts taken separately.
            </p>

            <p class="example">
              Example<br>
              When an architect designs a house, he can't design the rooms taken separately.<br>
              The rooms are all interconnected, and if he wants to make the bathroom bigger, he knows that this
              has an impact on other rooms and the structure of the house itself.
              For the best possible house, no room might be the best possible room.<br>
              Everything needs to be evaluated against the improvement of the whole.<br>
            </p>

            <p>This is directly reflected in how we develop the software itself.<br>
              We often act and think in silos, and our focus easily shifts from improving the software as a whole to improving specific elements we see as important.<br>
                UI-redesigns, performance optimizations and better code abstraction layers - there is always something we can make better.<br>
                At the end of the day it comes down to what we have done with our limited time, money and information.<br>
                If we only improve the parts without the focus on the improvement of the system as a whole, we will not only be wasting
                a lot of opportunities to deliver the best possible result to our customers, we will make the system worse.
            </p>
          </section>
          
          <section class="content">
            <h2>Hidden Cost</h2>
      
            <p>We assume that the right process (for example an agile framework) will bring everything together, but
            the truth is, that any process is limited to means of coordination.<br>
            We need a good process, but it is no substitute for integrative methods.</p>
            
            <figure>
              <img src="img/coordinationVsIntegration.svg" alt="">
              <figcaption>Think-Make-Check circle: coordination VS integration</figcaption>
            </figure>
            
            <p>The difference, between coordination and integration. Overlapping areas represent a unification of two or more disciplines.<br>
              This can be seen as a shared language or artifact. Something that is common in both disciplines.<br>
              Without it, we are only able to throw our work over the fence for the next team to continue.<br>
            </p>

            <p class="example">There is something called a "Developer Handoff".<br>
              A process, where a designer will hand the results over to the development team.<br>
              If the designer made a good job, the developers are able to understand enough to implement the necessary code.<br>
              The work is divided, and for a time this seems to be a great idea - but over time, we can see what we have missed.<br>
              The necessary interactions between designers and developers.<br>
              Even if the developers are able to implement the code, what about the shared understanding of the whole?<br>
              Why are the designs made that way?<br>
              Developers can get angry and frustrated. "What are the designers doing? This is way to complicated!".<br>
            </p>

            <p>For many companies, this is the default behaviour. It is the culture of our economy: the division of labor.<br>
            As a result, a strict process might be seen as overly beneficial to your employee.<br>
            To be a worker in a process, your work is more easily measured and checked, to optimize for efficiency.<br>
            Coordination enables us to do things the right way.</p>

            <p>On the other hand, we have integration.<br>
            Integrated teams share an understanding of the software and its goals.<br>
            Only then, the question can be answered: Are we improving our software with this change?<br>
            A team can be very efficient in adding new features, but features do not guarantee an improvement.<br>
            Integration enables us to do the right thing.<br>
          </p>
            
            <p>This is why we need coordination and integration. They are a complementary pair.<br>
              On a coordination level, we answer the questions on how to do things. This leads to knowledge.<br>
              Integration is a step up. By asking "why" questions we are able to gain understanding. 
              Only with coordination and integration we can add value efficiently.
            </p>
            
            <figure>
              <img src="img/infoknowlunder.svg" alt="">
              <figcaption>Information -> Knowledge -> Understanding</figcaption>
            </figure>

            <p class="quote">An ounce of information is worth a pound of data.<br>
              An ounce of knowledge is worth a pound of information.<br>
              An ounce of understanding is worth a pound of knowledge.
            </p>

            <p>
              Can we make choices to enable better integration?<br>
              I think that we can, by resolving a duality <br>

            </p>

            <p>What if we change the system?<br>
              What if we could have a system where an integrative method is as essential as the process we have chosen?<br>
              I think that we have to address a situation at the very core of how we work.<br>
              There is a duality in how we work. If we would resolve this, we would be able to unify different disciplines.<br>
            </p>
          </section>

          <section>
            <h2>Duality</h2>

            <p class="example">You are in sprint 32.<br>
              Someone shows you a database schema.<br>
              Do we need field "x"?<br>
              You could say: it depends.<br>
              It depends on what?<br>
              It depends on the context<br>
            </p>
            <p>Your answer could be: Yes, we need field "x" because it is required for the user registration process and for...<br>
                This is an answer someone might expect, but to be able to give it, a developer needs to know all the scenarios
                that need field "x" and this information might not be easily found, as it got complected into the structure.
            </p>
              
            <figure>
              <img src="img/divide.svg" alt="">
              <figcaption>the divide</figcaption>
            </figure>

            <p>Design and Testing will describe the software in terms of scenarios (seen on the left).<br>
              On the right side, developers will describe the software in terms of an executable software construct.</p>
              
            <p>This is the duality. On one hand, we have a scenario based thinking that lets us define in a very human way how things
              should work. This is in fact how we -as humans- try to make sense of the word that surrounds us.<br>
              Like: "the user is able to register by providing the needed information".
            </p>
              
            <p>On the other hand, we write software, because we need something that is machine-executable.
              We add methods, classes, components, ..., to the software construct, so that it is capable of running our scenario.
              "we need to implement a new service, the form-component needs to include field x, ..."</p>
          
              <figure>
                  <img src="img/driftapart.svg" alt="">
                  <figcaption>drifting apart</figcaption>
              </figure>

              <p>This is the divide at the very core of how we work.
              </p>
          </section>



          <section>
            <h2>Problems</h2>

              <p>From a developer perspective, this duality creates a world of problems. Here are my top 3.</p>
              
              <h4>1. complecting scenarios</h4>
              <p>After adding functionality to the same part of our construct, we might fail to reason about it.<br>
                What scenarios have shaped this component?<br>
                Why is this if/else here?<br>
              If we are not able to reason about our code, how can we make confident changes?<br>
              Complecting scenarios will result in complexity.</p>

              <h4>2. enabling unwanted scenarios</h4>
              <p>When we implement a new feature, we add new functionality to parts of our construct - 
                but what unwanted scenarios we have we accidentally enabled, too? can we test this?<br>
                Bob Martin tells me that i need "negative tests". It is like the advice to "expect the unexpected".
              </p>
              
              <h4>3. change in mindset</h4>
              <p>We want to increase the power of our software.<br>
              The wish is, that the software will be so well constructed, that it would be easy to enable possible future scenarios, or even possible future projects.<br>
              We focus on our powerful software - and less on the needs of our users.</p>
              <br>
          </section>


          <section>
            <h2>Resolving</h2>
            <p>Different specializations not only need to be coordinated - they need to be integrated as well.<br>
              To enable integration between two disciplines, we need something that serves as a common ground.<br>
              In other words, it would be beneficial to talk the same language when we talk about software.<br>
          </p>

          <p><b>The goal</b> is to keep an artifact (a scenario) during the whole process. From design over to development and testing.<br>
          </p>

          </p>
          </section>


          <section>
            <h2>Experiment</h2>

            <p>At this point, it all comes down to an experiment.<br>
              What will happen if the scenarios we want to enable are directly reflected in our code?<br>
            </p>

            <p>For this experiment, we will develop a simple image slider.<br>
              Our team has agreed on a couple of requirements.<br>
              <ul>
                <li>only one slide (the current slide) is shown</li>
                <li>The user is able to slide to the left and right.</li>
                <li>The slider can rotate in both directions.</li>
                <li>The slider will have a play function and slides after x ms.</li>
                <li>The slider can be paused at any time.</li>
                <li>Bulletpoints can be used to jump to a specific slide.</li>
                <li>If the user changes slides manually, the slider will pause.</li>
                <li>The slider will start to play automatically</li>
              </ul>
            </p>

            <p>Designers have sketched some first designs, and included input from the developers.<br>
              They have found async processes and edge-cases that need to be reflected in the UI as well.<br>
              <ul>
                <li>The slides are loaded asynchronously. (show a spinner ?)</li>
                <li>If there is only one slide, the slider has no functionality (show no buttons ?)</li>
              </ul>
            </p>

            <p>The developers started coding and this is the scaffolding of the discussed scenarios in code:<br>
            </p>

          <div style="background: #f0f3f3; overflow:auto;font-size:.8em; padding:1em; ">
  <pre style="margin: 0; line-height: 125%;width:0;">(scenario) <span style="color: #555555">=&gt;</span> {
  <span style="color: #006699; font-weight: bold">const</span> items <span style="color: #555555">=</span> scenario(loadItems, [url]).value;
  <span style="color: #006699; font-weight: bold">if</span>(items) {
    <span style="color: #006699; font-weight: bold">const</span> index <span style="color: #555555">=</span> scenario(showCurrentSlide, [items]).value;
    <span style="color: #006699; font-weight: bold">if</span>(items.length <span style="color: #555555">&gt;</span> <span>1</span>) {
      scenario(jumpToSlide, [items.length]);
      <span style="color: #006699; font-weight: bold">const</span> leftRight <span style="color: #555555">=</span> scenario(slideLeftRight, [index, items.length]);
      <span style="color: #006699; font-weight: bold">if</span>(leftRight) {
        scenario(rotate, [index, items.length]);
        <span style="color: #006699; font-weight: bold">const</span> isPlaying <span style="color: #555555">=</span> scenario(playPause, [<span>3000</span>]).value;
        <span style="color: #006699; font-weight: bold">if</span>(isPlaying) {
          scenario(pauseOnIndexChange);
        }
        scenario(autoplay);
      }
    }
  }
};</pre></div>
      <p>A scenario we defined has made its way into the code.<br>
        If a developer needs to understand what a software can do, this is a great way to start.<br>
      </p>

      <figure>
          <img src="img/scenariosandconstruct.svg" alt="">
          <figcaption>scenarios are like threads that use different parts of the construct.</figcaption>
      </figure>

      <p>A scenario like "the user needs to register before he can post a comment" is a layer above the software construct.<br>
        For example: A button to send a request, or the service that makes an api call, can be part of the same scenario, even if they are in different parts of the construct.<br>
        Usually, the developer needs to keep those scenarios in his head when he tries to understand the code.<br>
      </p>

      <p>If you want to go into the details - <a href="https://codesandbox.io/s/first-final-design-6xccf">here is the complete code</a>.<br>
        There is a lot to unpack how the modular scenario system is constructed.<br>
        A detailed description will follow in the next article.<br>
      </p>
    </section>


    <section>
      <h2>First Findings</h2>
      <p>
        <ol>
          <li>This shows that it is indeed possible to keep the artifact as a central element.<br>
            That we have the possibility to transition from the scenario in the requirement to the scenario in code.<br>
            Not all requirements can be modularized this way.<br>
            For example, technical requirements like "needs to be compatible with IE 11" are excluded.<br>
          </li>
          <li>We have provided a great place to start, when we want to understand our code.<br>
            In this scenario scaffolding, we find all the behaviours we enabled for this component.<br>
          </li>
          <li>Making changes requires the developer to understand how the scenarios need to be constructed.<br>
            If the developer understands this modular system, he is able to add new scenarios, without knowing how other scenarios are implemented.<br>
          </li>
          <li>That it is possible to integrate scenario based programming into the current way we write UI Components.<br>
            This is demonstrated by using a react-hook.<br>
          </li>
        </ol>
      </p>
    </section>


    <section>
        <h2>What Is Next?</h2>

        <p>In the next article i go into code details.<br>
          I will show the benefits for testing and describe a full circle with this integrative core.<br>
          It turns out that scenarios really shine, when we look at intra-component functionality.<br>
          Use <a href="../../rss.xml">this RSS-Feed</a> to be notified.<br>
          Or follow me at twitter <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>.<br>
        </p>

        <p>Thanks for reading this article.<br>
          If you would like to say hello, please do so.<br>
          Do you have other ideas on how to enable integration as a central part of your process?<br>
        </p>

        <p>
          <h4>If you want to know more...</h4>
          <ul>
            <li><a href="https://medium.com/@lmatteis/b-threads-programming-in-a-way-that-allows-for-easier-changes-5d95b9fb6928">B-threads article from Luca Matteis</a></li>
            <li><a href="http://www.wisdom.weizmann.ac.il/~bprogram/">Behavioral Programming Introduction (page)</a></li>
            <li><a href="https://www.youtube.com/watch?v=EbLh7rZ3rhU">Systems Thinking by Dr. Russell Ackoff (video)</a></li>
            <li><a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple made Easy - Rich Hickey (video)</a></li>
            <li><a href="http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf">Can Programming Be Liberated, Period? (pdf)</a></li>
            <li><a href="https://medium.com/@dschnr/better-reusable-react-components-with-the-overrides-pattern-9eca2339f646">Overrides Pattern (page)</a></li>
          </ul>
        </p>
    </section>


  </article>
  <aside>
    <img src="img/profile.jpg"/>
    <div class="author">Thomas Deutsch</div>
    <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>
  </aside>
  </div>

  <script>
    var el = document.getElementById("video1");
    el.onclick = function() {
      var newEl = document.createElement('p');
      newEl.innerHTML = '<iframe width="100%" height="315" src="https://www.youtube.com/embed/OqEeIG8aPPk?start=560&autoplay=1&showinfo=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>';
      el.parentNode.replaceChild(newEl, el);
    };
  </script>
</body>
</html>