<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>The Need For Integration</title>
  <meta name="description" content="The Need For Integration">
  <meta name="author" content="Thomas Deutsch">
  <link rel="stylesheet" href="styles.css?v=1.0">
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <div class="container">
      <article>
          <header>
            <div class="date">January, 2020</div>
            <figure>
              <img src="img/integrationTitle.svg"/>
            </figure>
          </header>
          <section class="content">
            <p>One year ago, in January 2019, Chris Coyier released the article <a href="https://css-tricks.com/the-great-divide/">The Great Divide</a>.
              He shows that we are facing some challenges by introducing new disciplines and sub-disciplines to the field of software development.<br> 
              What do you need to learn, to call yourself a frontend developer? What even is frontend-development?<br>
              The difference between "front of the frontend" (UX, UI-Design, a11y) and "back of the frontend" (programming) shows a divide in
              specializations - that is not without a cost.
            </p>
            <p>A cost that needs to be addressed: with every spezialization comes the need for integration.<br>
              I would argue, that this is mostly overlooked and it creates one of the biggest problems in modern software development.
            </p>
            <p>In this article, i will define the cost that comes with our specializaions and why we need to address it.<br>
              I will describe a systemic problem at the very core of how we work, <br>
              and show a solution to resolve this problem - something you can use today.
            </p>
            <p>This is all in good spirit, as this article is about improvement and a positive outlook on what is possible.</p>
            <p>I hope that you will, more often then not, find a way to discover that integrated teams can be much bigger than the sum of its parts.</p>
          </section>
      
          <section class="content">
            <h2>System Of Parts</h2>

            <p>A way to look at our situation, is through the lens of Systems Thinking.</p>
            <p>Systems Thinking was pioneered by the work of <a href="https://en.wikipedia.org/wiki/Russell_L._Ackoff">Russell Ackoff</a>. This is one of my favorite clips, where
              he talks about improvement. Something that you may see as fitting for this article.</p>
            <iframe width="100%" height="315" src="https://www.youtube.com/embed/OqEeIG8aPPk?start=560" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>
            <p>I will use some of his words, for the following explanation.</p>

            <p>We are dividing the system of software development into parts (specializations).
                The assumption is, that if we improve every part separately, the system as a whole will improve.<br>
                But this is very misleading.<br>
                A system is a whole, that can not be divided into independent parts.<br>
                The parts are all interconnected. Improving a part will not necessarily improve the system as a whole.<br>
                Most properties of a system will derive from the interaction of its parts - not from the parts taken separatly.
            </p>

            <p class="example">
              Example<br>
              When an architect designs a house, he can not design the rooms taken separately.<br>
              The rooms are all interconnected, and if he wants to make the bathroom bigger, he knows that this
              has an impact on other rooms and the structure of the house itself.
              For the best possible house, no room might be the best possible room.<br>
              Everything needs to be evaluated against the improvement of the whole.<br>
            </p>

            <p>This is directy reflected in how we develop the software itself.<br>
              We often act and think in silos, and our focus easily shifts from improving the software as a whole to improving specific elements we see as important.<br>
                UI-redesigns, performance optimizations and better code abstraction layers - there is always something we can make better.<br>
                At the end of the day it comes down to what we have done with our limited time, money and information.<br>
                If we only improve the parts without the focus on the improvement of the system as a whole, we will not only be wasting
                a lot of opportunities to deliver the best possible result to our customers, we will make the system worse.
            </p>
          </section>
          
          <section class="content">
            <h2>Hidden Cost</h2>
      
            <p>Because all the parts are interconnected, every specialization we introduce will create the need to be integrated into the whole.<br>
            We assume that the right process (for example an agile framework) will bring everything together, but
            the truth is, that a process is limited to means of coordination. Integration on the other hand, is about a common ground, an overlap of different
            disciplines that can result in a shared language and artifact.<br>
            We need a good process, but it is not a substitute for integrative methods.</p>

            <p>Modern software development is often associated with iterative processes.<br>
              Any agile framwork will make use of one or multiple of those iteraive processes. In this case visualized by a think-make-check circle.<br>
              Here, the process is shown in two different ways. On the left, coordination with an emphasis on direction. Integration on the right side where
              different fields of specialization are shown as circles.
            </p>
            
            <figure>
              <img src="img/coordinationVsIntegration.svg" alt="">
              <figcaption>Think-Make-Check Circle in two views. On the left: coordination. On the right: integration</figcaption>
            </figure>
            
            <p>On the right side, we see overlapping areas. They are a common ground, where we can find ways to understand each other - to work together.<br> 
            Without it, we are only able to throw our work over the fence for the next team to continue.<br>
            </p>

            <p class="example">There is something called a "Developer Handoff".<br>
              After completion of his work, a designer will hand his work results over to the developer team.<br>
              If he made a good job, the developers are able to understand enough to implement the neccecary code to make an interactive UI.<br>
              The work is clearly divided - but what is easily missed? It is the nessecary interactions between designers and developers.<br>
              Even if the developers are able to implement the code, what about the shared understanding of the whole?<br>
              Why are the designs made that way? What about the developers who would love to give an opinion before the designs are finished?<br>
              Are those issues addressed in your team? If not, then there is the danger of destroying an environment where everyone can feel engaged to deliver the best possible solution.
            </p>

            <p>For many companies, this is the default behaviour. It is the culture of our economy: the division of labor.<br>
            As a result, a strict process might be seen as very benificial to our employees.<br>
            To be a worker in a process, your work is more easily measured and checked, to optimize for efficency.<br>
            It is a lot like working on an assembly line.<br> 
            We are focused on doing things the right way.<br>
            This is the goal of coordination.</p>

            <p>On the other hand, we have integration.<br>
            The goal of integation is, to do the right thing.<br> 
            To create a common ground where we are able to work on a shared understanding of what we try to accomplish,<br>
            so that we can look at the result of our work, learn from our mistakes and gain insight about the next steps we need to take.<br>
            A team can be very efficent and finish a lot of features, but features do not guarantee an improvement.<br>
            Only if the system is improved as a whole, a feature will add value.<br>
            This point is also explained by W. Edwards Deming: <br>
          </p>

            <p class="quote">
            "It is not enough to do your best; you must know what to do, and then do your best"
            </p>
            
            <p>This is why we need coordination AND integration. They are a complementary pair.<br>
              At the moment, we are very much devoted to do things right, even if we do the wrong thing.<br>
              Unfortunatly, this makes the wrong thing even wronger.<br>
              The agile process can help us, but it will not prevent us from slipping back into the old waterfall-behaviour.<br>
              Even in your sprint reviews, you can learn nothing about the values you added in this iteration.<br>
            </p>

            <p>I can make many points</p>


            </p>
          </section>


          <section>
            <h2>Duality</h2>

            <p>A duality is deeply ingrained in how we work. The following example describes a situation where two people are hindered from having a good conversation, because
              of that duality
            </p>

            <p class="example">You are in sprint 32.<br>
              Someone shows you a database schema.<br>
              Do we need the field "x"?<br>
              You could say:  it depends.<br>
              It depends on what?<br>
              It depends on the context.<br>
              Or your answer could be: Yes, we need field "x" because it is required for the user registration process.
              But you need to know all the scenarios that need field "x" to be able do give an answer of this quality.</p>
              
            <p>On one hand, we have a scenario based thinking that lets us define in a very human way how things
              should work.<br>
              "the user should be able to register by providing the needed information"
            </p>
              
            <p>On the other hand, we write software, because we need something that is machine-executable.
              We add methods, classes, components, ..., to our software construct, so that it is capable of running our scenario.
              "we need to implement a new service, the form-component needs to include field x, ..."</p> 
              
              <p>As our software grows, it becomes increasingly difficult to make the connection between the written software
                ( the software construct ) and the scenario ( the artifact ).</p>
              
          
              THE DRIFTING APART IMAGE

              <p>
              Designers and Testers are seeing scenarios, a developer will see the software construct. 
              Developers alienate themselfes from the rest of the team on many levels.</p>
              
              
              <h3>enabling unwanted scenarios</h3>
              <p>When we implement a new feature, we add new functionality to parts of our construct - 
                but what unwanted scenarios we have we accidently enabled, too? can we test this?
                Bob Martin tells me we need "negative tests" - but how do we find them?
              </p>

              <h3>complecting scenarios</h3>
              <p>After some changes to the same part of our construct, we might fail to reason about it. What scenarios have shaped this component? Why is this if/else here?
              If we are not able to reason about our code - how confident can we be in making changes to it?</p>
              
              <h3>powerful software</h3>
              <p>
              Instead of enabling scenarios - we see the increase in the power of parts of our software.<br>
              The wish is, that the software will be so well designed, that it would be easy to enable possible future scenarios.<br>
              Because we choose the right language, framework or abstraction.<br>
              We want to create something that can be used in other projects as well.<br>
              Those are good goals, but we easily fall into a trap. <br>
              In our minds, it becomes more about our/your powerful software - and less about the needs of the users.</p>
              
              <p>
              We see this as a given.
              This is how we do things
              But not any more - you have ha choice!
              It can make a lot of sense to</p>

              <p>Maybe this is what Rich Hickey meant by saying "We need to learn to address our coded, based on the artifacts.</p>
              
              
              <p>We can break the duality - we have a choice. 
              It requires change - a bit of change in mindset as well - mostly from the developers - i am sorry.</p>
              
              We can address our code, based on the artifacts and we want do this based on a simple principle: to value interactions, meaningful conversations and a shared artifact to work on.


          </section>




        </article>
        <aside>
          <img src="img/profile.jpg"/>
          <div class="author">Thomas Deutsch</div>
          <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>
        </aside>
  </div>
</body>
</html>