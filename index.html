<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>The Need For Integration</title>
  <meta name="description" content="The Need For Integration">
  <meta name="author" content="Thomas Deutsch">
  <link rel="stylesheet" href="styles.css?v=1.0">
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <div class="container">
      <article>
          <header>
            <div class="date">January, 2020</div>
            <figure>
              <img src="img/integrationTitle.svg"/>
            </figure>
          </header>
          <section class="content">
            <p>One year ago, in January 2019, Chris Coyier released the article <a href="https://css-tricks.com/the-great-divide/">The Great Divide</a>.
              He shows that we are facing some challenges by introducing new disciplines and sub-disciplines to the field of software development.<br> 
              What do you need to learn, to call yourself a frontend developer? What even is frontend-development?<br>
              The difference between "front of the frontend" (UX, UI-Design, a11y) and "back of the frontend" (programming) shows a divide in
              specializations - that is not without a cost.
            </p>
            <p>A cost that needs to be addressed: with every spezialization comes the need for integration.<br>
              I would argue, that this is mostly overlooked and it creates one of the biggest problems in modern software development.
            </p>
            <p>In this article, i will define the cost that comes with our specializaions and why we need to address it.<br>
              I will describe a systemic problem at the very core of how we work, <br>
              and show a solution to resolve this problem - something you can use today.
            </p>
            <p>This is all in good spirit, as this article is about improvement and a positive outlook on what is possible.</p>
            <p>I hope that you will, more often then not, find a way to discover that integrated teams can be much bigger than the sum of its parts.</p>
          </section>
      
          <section class="content">
            <h2>System And Parts</h2>

            <p>A way to look at our situation, is through the lens of Systems Thinking.</p>
            <p>Systems Thinking was pioneered by the work of <a href="https://en.wikipedia.org/wiki/Russell_L._Ackoff">Russell Ackoff</a>. This is one of my favorite clips, where
              he talks about improvement. Something that you may see as fitting for this article.</p>
            <iframe width="100%" height="315" src="https://www.youtube.com/embed/OqEeIG8aPPk?start=560" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>
            <p>I will use some of his words, for the following explanation.</p>

            <p>We are dividing the system of software development into parts (specializations).
                The assumption is, that if we improve every part separately, the system as a whole will improve.<br>
                But this is very misleading.<br>
                A system is a whole, that can not be divided into independent parts.<br>
                The parts are all interconnected. Improving a part will not necessarily improve the system as a whole.<br>
                Most properties of a system will derive from the interaction of its parts - not from the parts taken separatly.
            </p>

            <p class="example">
              Example<br>
              When an architect designs a house, he can not design the rooms taken separately.<br>
              The rooms are all interconnected, and if he wants to make the bathroom bigger, he knows that this
              has an impact on other rooms and the structure of the house itself.
              For the best possible house, no room might be the best possible room.<br>
              Everything needs to be evaluated against the improvement of the whole.<br>
            </p>

            <p>This is directy reflected in how we develop the software itself.<br>
              We often act and think in silos, and our focus easily shifts from improving the software as a whole to improving specific elements we see as important.<br>
                UI-redesigns, performance optimizations and better code abstraction layers - there is always something we can make better.<br>
                At the end of the day it comes down to what we have done with our limited time, money and information.<br>
                If we only improve the parts without the focus on the improvement of the system as a whole, we will not only be wasting
                a lot of opportunities to deliver the best possible result to our customers, we will make the system worse.
            </p>
          </section>
          
          <section class="content">
            <h2>Hidden Cost</h2>
      
            <p>Because all the parts are interconnected, every specialization we introduce will create the need to be integrated into the whole.<br>
            We assume that the right process (for example an agile framework) will bring everything together, but
            the truth is, that a process is limited to means of coordination. Integration on the other hand, is about a common ground, an overlap of different
            disciplines that can result in a shared language and artifact.<br>
            We need a good process, but it is not a substitute for integrative methods.</p>

            <p>Modern software development is often associated with iterative processes.<br>
              Any agile framwork will make use of one or multiple of those iteraive processes. In this case visualized by a think-make-check circle.<br>
              Here, the process is shown in two different ways. On the left, coordination with an emphasis on direction. Integration on the right side where
              different fields of specialization are shown as circles.
            </p>
            
            <figure>
              <img src="img/coordinationVsIntegration.svg" alt="">
              <figcaption>Think-Make-Check circle: coordination VS integration</figcaption>
            </figure>
            
            <p>On the right side, we see overlapping areas. They are a common ground, where we can find ways to share an understanding - to work together.<br>
              Without it, we are only able to throw our work over the fence for the next team to continue.<br>
            </p>

            <p class="example">There is something called a "Developer Handoff".<br>
              After completion of his work, a designer will hand his work results over to the development team.<br>
              If he made a good job, the developers are able to understand enough to implement the neccecary code.<br>
              The work is clearly divided - but what is easily missed?<br>
              The nessecary interactions between designers and developers!<br>
              Even if the developers are able to implement the code, what about the shared understanding of the whole?<br>
              Why are the designs made that way? What about the developers who would love to give an opinion before the designs are finished?<br>
              Are those issues addressed in your team? If not, then there is the danger of destroying an environment where everyone has a chance to
              be engaged to deliver the best possible software.
            </p>

            <p>For many companies, this is the default behaviour. It is the culture of our economy: the division of labor.<br>
            As a result, a strict process might be seen as overly benificial to our employee.<br>
            To be a worker in a process, your work is more easily measured and checked, to optimize for efficency.<br>
            It is a lot like working on an assembly line.<br> 
            We are focused on doing things the right way.<br>
            This is the goal of coordination.</p>

            <p>On the other hand, we have integration.<br>
            The goal of integation is, to do the right thing.<br> 
            To create a common ground where we are able to work on a shared understanding of what we try to accomplish,<br>
            so that we can look at the result of our work, learn from our mistakes and gain insight about the next steps we need to take.<br>
            A team can be very efficent and finish a lot of features, but features do not guarantee an improvement.<br>
            Only if the software will be improved as a whole, a feature will add value.<br>
            This point is also explained by W. Edwards Deming: <br>
          </p>

            <p class="quote">
            "It is not enough to do your best; you must know what to do, and then do your best"
            </p>
            
            <p>This is why we need coordination AND integration. They are a complementary pair.<br>
              At the moment, we are very much devoted to do things right, even if we do the wrong thing.<br>
              Unfortunatly, this makes the wrong thing even wronger.<br>
              An agile process can help us, but it will not prevent us from slipping back into the old waterfall-behaviour.<br>
              Even in our sprint reviews, we can learn nothing about the values we added in the latest iteration.<br>
            </p>
          </section>
          <section>
            <h2>Our System</h2>

            <p>Maybe this is the way it is.<br>
            At the beginning, everyone is on board, we talk about our goals and about the software we want to build.
          </p>

            <figure>
                <img src="https://www.boxuk.com/wp-content/uploads/2019/10/user-story-mapping-body-11.jpg" alt="">
                <figcaption>people come together to work a userstory-map</figcaption>
              </figure>
              <p>

            
            This can not go on forever, we need to make something. Documentations, creating designs and writing code.<br>
            And the more we produced the less we are able to make big changes. Agility has its limits and at some point, the path is mostly set.<br>
            Maybe we should rebrand our agile projects to be more honest, so we don't raise false expectations.<br> 
            "10-sprint agile then mostly waterfall"?<br>
          </p>

          <p>I think that we can do something about it - a choice to value integration and to stand up for it.<br>
            Literally, you can stand up to leave your desk, talk to someone about the software you are building.<br>
            Ask the desingers or developers some important questions or ask someone to help you.<br>
            Sometimes this not that easy, because not everyone can see the value in those conversatoins.<br>
            Some of you might got the instructions to "not disturb" the designers or developers - you can ask me about my experience.
          </p>

          <p>This is hard work, and if it is not encouraged, your engagement will drop like a rock.<br>
            "people over process" - easier said than done.</p>
          
          <p><b>What would happen if we change the system?</b> To a system, where integration is as essential as coordination?<br>
            This system will provide a common ground that is not so easily lost.<br>
            I am sure, this can be done in many different ways. I will show you one.<br>
            It is about resolving a duality at the very core of how we work.<br>
            The goal is, to have something that unifies designing, programming and testing.<br>
          </p>
          </section>


          <section>
            <h2>Duality</h2>

            <p>The following example describes a situation where we are hindered from having a meaningful conversation, because
              of a duality we see as a given.
            </p>

            <p class="example">You are in sprint 32.<br>
              Someone shows you a database schema.<br>
              Why do we need field "x"?<br>
              You could say: it depends.<br>
              It depends on what?<br>
              It depends on the context<br>
            </p>
            <p>Your answer could be: Yes, we need field "x" because it is required for the user registration process and for...<br>
                This is an answer someone might expect, but to be able to give it, a developer needs to know all the scenarios
                that need field "x" and this information is not easily found.
            </p>
              
            <figure>
              <img src="img/divide.svg" alt="">
              <figcaption>the divide</figcaption>
            </figure>
              
            <p>On one hand, we have a scenario based thinking that lets us define in a very human way how things
              should work.<br>
              "the user is able to register by providing the needed information"
            </p>
              
            <p>On the other hand, we write software, because we need something that is machine-executable.
              We add methods, classes, components, ..., to our software construct, so that it is capable of running our scenario.
              "we need to implement a new service, the form-component needs to include field x, ..."</p>
            <p>As our software grows, it becomes increasingly difficult to make the connection between the written software
              (the software construct) and the scenario (an artifact).</p>
              
          
              <figure>
                  <img src="img/driftapart.svg" alt="">
                  <figcaption>drifting apart</figcaption>
              </figure>


              <p>From a developer perspective, this divide creates a world of problems. Here are my top 4.</p>
              
              <h4>1. complecting scenarios</h4>
              <p>After adding functionality to the same part of our construct, we might fail to reason about it.<br>
                What scenarios have shaped this component?<br>
                Why is this if/else here?<br>
              If we are not able to reason about our code, how can we make confident changes?</p>

              <h4>2. enabling unwanted scenarios</h4>
              <p>When we implement a new feature, we add new functionality to parts of our construct - 
                but what unwanted scenarios we have we accidently enabled, too? can we test this?<br>
                Bob Martin tells me that i need "negative tests" - but it is not that easy.
              </p>
              
              <h4>3. change in mindset</h4>
              <p>We want to increase the power of our software.<br>
              The wish is, that the software will be so well constructed, that it would be easy to enable possible future scenarios, or even possible future projects.<br>
              We focus on our powerful software - and less on the needs of our users.</p>

              <h4>4. programmer convenience</h4>
              <p>The constructs have attributes of themselfes, as we like to think about elegant abstractions or the latest version of framework x.<br>
                Without the focus on the software as a whole, we see all the promoted benefits of adding framework x - and only some of the drawbacks.
                Before i quote every part of the talk <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple Made Easy</a> by Rich Hickey, please
                go ahead and watch it.<br>
              </p>

              <p>I would argue that developers suffer the most from the consequences of this divide.<br>
              But those problems are self-inflicted. Developers need to find ways to assess the construct based on the artifacts.</p>

              <p>At the end, everbody needs to pay the consequences. From my point of view, this duality is one of the biggest problems in modern software development.<br>
                Maybe we need another crisis for this to change. Maybe the growing success of the no-code movement will teach us.<br>
              </p>

              <p>Luckily, this article is about improvement and a positive outlook, and i promised a practical solution for this problem.<br>
                It is not a silver bullet, but i hope i can demostrate that there is a choice.<br>
              </p>
          </section>


          <section>
            <h2>A Plan</h2>
            <p>At this point, it all comes down to a simple experiment.<br>
              What will happen the scenarios we want to enable are directly reflected in our code?<br>
              What will happen if the scenarios (the artifact) is always present and unifies design, development and testing?<br>
            </p>

            <p>For this experiment, we will develop a simple image slider.<br>
              Our team has agreed on a couple of requirements.<br>
            <ul>
              <li>The user is able to slide to the left and right.</li>
              <li>The slider can rotate in both directions.</li>
              <li>The slider will have a play function and slides after x seconds.</li>
              <li>The slider can be paused at any time.</li>
              <li>Bulletpoints can be used to jump to a specific slide.</li>
              <li>If the user slides to the left or the right, the slider will pause.</li>
              <li>The slider will start to play automatically</li>
            </ul>
          </p>
          <p>Designers have scetched some first designs, and included input from the developers.<br>
            They have found some technical requirements that need to be reflected in the UI.<br>
          <ul>
            <li>The slides are loaded asyncrounously. (show a spinner)</li>
            <li>If there is only one slide, the slider has no functionality (show no buttons)</li>
          </ul>
          <p>At this point, we can talk about naming. Can we find short names for the different scenarios?<br>
            And how do we name the specific events that will happen? For example: sliding to the left = slideLeft?<br>
          </p>

          <p>Lets see what it could look like to implement the scenarios.<br>
          For this, i have used a lot of ideas from "behavioural programming" or "scenario based programming".<br>
        </p>

          </p>
          <p class="code">
            index = state(0);
            items = scenario(loadItems(url));
            if(items && items.length > 0) {

            }

          </p>
          </section>

        </article>
        <aside>
          <img src="img/profile.jpg"/>
          <div class="author">Thomas Deutsch</div>
          <a href="https://twitter.com/thomas_deutsch">@thomas_deutsch</a>
        </aside>
  </div>
</body>
</html>